======================== INSERT SORT ===========================

- de reeks wordt virtueel opgedeeld in een gesorteerde (linker helft) en ongesorteerde
    (rechter helft).
- van links naar rechts wordt ieder element (begin bij index 1) vergeleken met het vorige element
    -> als het kleiner is dan het vorige element dan wordt het element tijdelijk opgeslagen in
        een variabele en zullen alle elementen links een plek naar rechts opschuiven. Tot slot zal
        het temp element op index 0 worden geplaatst
    -> als het hetzelfde of groter is dan het vorige element dan staat het op de juiste plek
        en ga je naar het volgende element
- preferred for small data sets
- efficient in space


========================= MERGE SORT ===========================

- divide and conquer
- de reeks wordt telkens gehalveerd (n/2) totdat er uiteindelijk 1 element over blijft
- het algoritme gebruikt extra storage voor het sorteren; het gebruikt in totaal 3 structuren:
        -> 2 worden gebruikt voor het sorteren van iedere helft
        -> de laatste wordt gebruikt om de gesorteerde reeks in op te slaan door middel van
            van het steeds samenvoegen van de 2 gesorteerde reeksen
- dit gebeurd allemaal recursief.
- preferred for large data sets
- efficient in time

=================== MERGE INSERTION SORT =======================











=================== FORD-JOHNSON MERGE-INSERTION SORT =======================

"the algorithm has served little practical use as it requires complex data structures and is slower to execute than more common and simpler to implement sorts "

OBSERVATION ABOUT BINARY SEARCH => "the maximal number of comparisons needed to perform a binary search on a sorted sequence is the same when the number of elements is 2^n
                                    and when it is 2^(n+1) - 1" 

                                    for example: looking for an element in a sorted sequence of 8 or 15 elements required the same number of comparisons

Jacobsthal numbers              =>  an integer sequence related to Fibonacci numbers. Similar to Fibonacci, where each term is the sum of the previous two terms,
                                    each term is the sum of the previous, plus twice the one before that. (0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, etc);

============================== EXPLANATION 1 ================================

n = the number of elements to sort

1. split the collection in n/2 pairs of 2 elements and order these elements pairwise. if the number of elements is odd, the last element of the collection isn't paired with any element.

2. Recursively sort the pairs of elements by their highest value. if the number of elements is odd, the last element is not considered a highest value and is left at the end of the
    collection. Consider that the highest values form a sorted list that we will call the main chain while the rest of the elements will be known as pend elements. Tag the elements
    of the main chain with the names a1, a2, a3, ..., a(n/2) then tag the pend elements with the names b1, b2, b3, ..., b(n/2). For every k, we have the relation b(k) <= a(k).

3. Insert the pend elements into the main chain, we know that the first pend element b1 is lesser than a1; we conside it to be part of the main chain which then becomes 
    {b1, a1, a2, a3, ..., a(n/2)}. Now, we need to insert the other pend elements into the main chain in a way that ensures that the size of the insertion area is a power of 2
    minus 1 as often as possible. Basically we will insert b3, in {b1, a1, a2} (we know that it is less than a3), then we will insert b2 into {b1, a1, b3} no matter where b3, was inserted.
    Note that during these insertions, the size of the insertion area is always at most 3.

    The value of the next pend element b(k) to insert into the main chain while minimizing the number of comparisons actually corresponds to the next Jacobsthal number. We inserted the
    element 3 first, so the next will be 5, then 11 then 21, etc.

    To sum up, the insertion order of the first pend elements into the main chain is as follows: b1, b3, b2, b5, b4, b11, b10, b9, b8, b7, b6, b21

============================== EXPLANATION 2 ================================

1.  Determine if the array is even or odd numbered in length. If odd, remove the last number, designate it as a ‘straggler’ and insert it later into the sorted array.
2.  Arbitrarily divide the sequence to sort into pairs of two values.
3.  Sort the pairs bitwise, so the order is always [less, greater].
4.  Sort the sequence recursively by the value of it’s largest pair.
5.  Create a new sequence ‘S’, by pulling out the [highest] value of each pair and inserting it into ‘S’.
6.  The remaining values form a temporary ‘pend’ array.
7.  Based on the length of ‘pend’, build the optimal insertion sequence using relevant Jacobsthal numbers.
8.  Loop through the elements in ‘pend’, and using the insertion sequence built in the previous step, use binary search to insert each ‘pend’ element into ‘S’.
9.  If a ‘straggler’ was found, do a leftover loop and insertion to complete the list.